EVENT=post-create type=CCpp remote!=1
        if grep '^TracerPid:[[:space:]]*[123456789]' proc_pid_status >/dev/null 2>&1; then
            # We see 'TracerPid: <nonzero>" in /proc/PID/status
            # Process is ptraced (gdb, strace, ltrace)
            # Debuggers have wide variety of bugs where they leak SIGTRAP
            # to traced process and nuke it. Ignore this crash.
            echo "The crashed process was ptraced - not saving the crash"
            exit 1  # abrt will remove the problem directory
        fi
        if grep -q ^ABRT_IGNORE_ALL=1 environ \
        || grep -q ^ABRT_IGNORE_CCPP=1 environ \
        ; then
            echo "ABRT_IGNORE variable is 1 - not saving the crash"
            # abrtd will delete the problem directory when we exit nonzero:
            exit 1
        fi
        # Try generating backtrace, if it fails we can still use
        # the hash generated by abrt-action-analyze-c
        [ ! -e core_backtrace ] && abrt-action-generate-core-backtrace
        # Run GDB plugin to see if crash looks exploitable
        [ -r coredump ] && abrt-action-analyze-vulnerability
        # Generate hash
        abrt-action-analyze-c &&
        abrt-action-list-dsos -m maps -o dso_list &&
        (
            # Try to save relevant log lines.
            # Can't do it as analyzer step, non-root can't read log.
            executable=`cat executable` &&
            base_executable=${executable##*/} &&
            uid=`cat $DUMP_DIR/uid` &&
            {
                user_log_full=`journalctl -q -b --since=-3m -n 99 _COMM="$base_executable" _UID="$uid"` &&
                while read line; do
                    if [[ $line != *" audit["* ]]; then
                        user_log=$user_log$line$'\n'
                    fi
                done <<< "$user_log_full"
                test -n "${user_log::-1}" && printf "User Logs:\n--%s--\n" "$user_log" >$DUMP_DIR/var_log_messages
                # Do not use '&&' here because if $user_log is the empty string
                # then the script does not continue to get the system logs
                {
                    # Remove the line below if you don't mind sharing data from the
                    # system logs with unprivileged users -> bugzilla.redhat.com/1212868
                    false &&
                    system_log_full=$log`journalctl -q -b --since=-3m --system -n 99 _COMM="$base_executable"` &&
                    while read line; do
                        if [[ $line != *" audit["* ]]; then
                            system_log=$system_log$line$'\n'
                        fi
                    done <<< "$system_log_full"
                    test -n "${system_log::-1}" && printf "System Logs:\n--%s--\n" "$system_log" >$DUMP_DIR/var_log_messages
                    # Always exit with true here, because the false at
                    # the beginning would cause the post-create hook to remove
                    # the current problem directory.
                    true
                }
            }
        )

EVENT=collect_xsession_errors type=CCpp dso_list~=.*/libX11.*
        #
        # Where is X session error log - traditional or new location?
        #
        xsession_errors=~/.xsession-errors
        test -f "$xsession_errors" || xsession_errors=~/.cache/gdm/session.log
        #
        # We do not want to abort further processing,
        # thus we do not fail (exit with nonzero) if the file isn't there:
        test -f "$xsession_errors" || { echo "No $xsession_errors"; exit 0; }
        test -r "$xsession_errors" || { echo "Can't read $xsession_errors"; exit 0; }
        executable=`cat executable` &&
        base_executable=${executable##*/} &&
        grep -F -e "$base_executable" "$xsession_errors" | tail -999 >xsession_errors &&
        echo "Element 'xsession_errors' saved"

# TODO: can we still specify additional directories to search for debuginfos,
# or was this ability lost with move to python installer?
EVENT=analyze_LocalGDB type=CCpp
        abrt-action-analyze-ccpp-local


# Bugzilla requires nonempty duphash
EVENT=report_Bugzilla type=CCpp duphash!=
        test -f component || abrt-action-save-package-data
        component="`cat component`"
        format="bugzilla_format.conf"
        test -f "/etc/libreport/plugins/bugzilla_format_$component.conf" \
                && format="bugzilla_format_$component.conf"
        formatdup="bugzilla_formatdup.conf"
        test -f "/etc/libreport/plugins/bugzilla_formatdup_$component.conf" \
                && formatdup="bugzilla_formatdup_$component.conf"
        reporter-bugzilla -b \
                -c /etc/libreport/plugins/bugzilla.conf \
                -F "/etc/libreport/plugins/$format" \
                -A "/etc/libreport/plugins/$formatdup"

# Send micro report
EVENT=report_uReport type=CCpp
        /usr/libexec/abrt-action-ureport

# update ABRT database after successful report to bugzilla
EVENT=post_report type=CCpp
        reporter-ureport -A -B

EVENT=analyze_CCpp type=CCpp
        abrt-action-perform-ccpp-analysis

# Reporting of C/Cpp problems
EVENT=report-gui type=CCpp
        report-gtk -- "$DUMP_DIR"

EVENT=report-cli type=CCpp
        report-cli -- "$DUMP_DIR"

EVENT=report_systemd-journal type=CCpp analyzer=abrt-journal-core
        reporter-systemd-journal --message-id 5ab0271ecf1941a2b89299716e880661 \
                                 -F /etc/libreport/plugins/catalog_journal_ccpp_format.conf
